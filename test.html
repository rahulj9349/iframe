<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Swiper 3-step Zoom (works)</title>

  <!-- Swiper CSS (v10) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@10/swiper-bundle.min.css" />

  <style>
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #f3f4f6;
      font-family: Arial, sans-serif;
    }

    .wrap {
      position: relative;
      width: 78%;
      max-width: 900px;
    }

    .mySwiper {
      width: 100%;
      height: 70vh;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.08);
      overflow: hidden;
    }

    .swiper-slide {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* The zoom container we manipulate */
    .zoom-container {
      width: 100%;
      height: 100%;
      touch-action: none; /* needed for pointer panning */
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .zoom-container img {
      max-width: 100%;
      max-height: 100%;
      user-select: none;
      -webkit-user-drag: none;
      transform-origin: center center;
      transition: transform 180ms ease; /* smooth for scale changes */
      will-change: transform;
      pointer-events: all;
    }

    /* controls */
    .controls {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      justify-content: center;
    }

    .btn {
      border: none;
      padding: 8px 14px;
      background: #0b5cff;
      color: #fff;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(11,92,255,0.15);
    }
    .btn:disabled { opacity: 0.45; cursor: default; box-shadow: none; }

    /* small helper when image is pannable */
    .grab { cursor: grab; }
    .grabbing { cursor: grabbing; }

    /* position pagination inside the card */
    .swiper-pagination { bottom: 10px !important; }
  </style>
</head>
<body>

  <div class="wrap">
    <div class="mySwiper swiper">
      <div class="swiper-wrapper">
        <div class="swiper-slide">
          <div class="zoom-container">
            <img draggable="false" src="https://picsum.photos/id/1015/1200/800" alt="">
          </div>
        </div>

        <div class="swiper-slide">
          <div class="zoom-container">
            <img draggable="false" src="https://picsum.photos/id/1024/1200/800" alt="">
          </div>
        </div>

        <div class="swiper-slide">
          <div class="zoom-container">
            <img draggable="false" src="https://picsum.photos/id/1033/1200/800" alt="">
          </div>
        </div>
      </div>

      <!-- pagination / nav -->
      <div class="swiper-pagination"></div>
      <div class="swiper-button-next"></div>
      <div class="swiper-button-prev"></div>
    </div>

    <div class="controls">
      <button id="zoomOut" class="btn">Zoom âˆ’</button>
      <button id="resetZoom" class="btn">Reset</button>
      <button id="zoomIn" class="btn">Zoom +</button>
    </div>
  </div>

  <!-- Swiper JS -->
  <script src="https://cdn.jsdelivr.net/npm/swiper@10/swiper-bundle.min.js"></script>

  <script>
    // ---- Configuration ----
    const zoomLevels = [1, 1.75, 3]; // 3-step zoom (you can adjust)
    let levelIndex = 0; // current zoom level index (0 => 1x)
    let currentScale = zoomLevels[levelIndex];

    // Pan state
    let tx = 0, ty = 0;        // current translate
    let lastTx = 0, lastTy = 0;
    let isPanning = false;
    let startX = 0, startY = 0;
    let maxX = 0, maxY = 0;

    // active slide elements
    let activeImg = null;
    let activeContainer = null;

    // init Swiper
    const swiper = new Swiper('.mySwiper', {
      slidesPerView: 1,
      centeredSlides: true,
      spaceBetween: 10,
      pagination: { el: '.swiper-pagination', clickable: true },
      navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev' },
      on: {
        init() { updateActiveElements(); updateButtons(); },
        slideChange() {
          // reset zoom on slide change
          resetAllTransforms();
          levelIndex = 0;
          currentScale = zoomLevels[levelIndex];
          tx = ty = lastTx = lastTy = 0;
          updateActiveElements();
          updateButtons();
        },
        resize() {
          // recalc bounds when resized
          calculateBounds();
        }
      }
    });

    // Get elements
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const resetBtn = document.getElementById('resetZoom');

    zoomInBtn.addEventListener('click', () => {
      if (levelIndex < zoomLevels.length - 1) levelIndex++;
      currentScale = zoomLevels[levelIndex];
      resetTranslation();
      applyTransform(true);
      updateButtons();
    });

    zoomOutBtn.addEventListener('click', () => {
      if (levelIndex > 0) levelIndex--;
      currentScale = zoomLevels[levelIndex];
      resetTranslation();
      applyTransform(true);
      updateButtons();
    });

    resetBtn.addEventListener('click', () => {
      levelIndex = 0;
      currentScale = zoomLevels[levelIndex];
      resetTranslation();
      applyTransform(true);
      updateButtons();
    });

    // Update which image/container is active
    function updateActiveElements() {
      const slideEl = swiper.slides[swiper.activeIndex];
      activeContainer = slideEl.querySelector('.zoom-container');
      activeImg = activeContainer ? activeContainer.querySelector('img') : null;
      // ensure transform reset on newly active image
      applyTransform(false);
      calculateBounds();
    }

    function calculateBounds() {
      if (!activeImg || !activeContainer) { maxX = maxY = 0; return; }

      // Use rendered (client) size to calculate bounds
      const contRect = activeContainer.getBoundingClientRect();
      const imgWidth = activeImg.clientWidth;
      const imgHeight = activeImg.clientHeight;

      const scaledW = imgWidth * currentScale;
      const scaledH = imgHeight * currentScale;

      maxX = Math.max(0, (scaledW - contRect.width) / 2);
      maxY = Math.max(0, (scaledH - contRect.height) / 2);

      // If current translation is outside new bounds, clamp
      tx = clamp(tx, -maxX, maxX);
      ty = clamp(ty, -maxY, maxY);
      lastTx = tx; lastTy = ty;
      applyTransform(false);
    }

    // Apply transform to active image
    function applyTransform(withTransition) {
      if (!activeImg) return;
      if (!withTransition) {
        activeImg.style.transition = 'transform 160ms ease';
      } else {
        activeImg.style.transition = 'transform 160ms ease';
      }
      activeImg.style.transform = `translate(${tx}px, ${ty}px) scale(${currentScale})`;

      // update cursor and pointer behavior
      if (currentScale > 1) {
        activeImg.classList.add('grab');
      } else {
        activeImg.classList.remove('grab');
        activeImg.classList.remove('grabbing');
      }
    }

    function resetTranslation() {
      tx = 0; ty = 0; lastTx = 0; lastTy = 0;
      calculateBounds();
    }

    function resetAllTransforms() {
      // clear transforms for all images (useful on slide change)
      document.querySelectorAll('.zoom-container img').forEach(img => {
        img.style.transform = '';
        img.style.transition = 'transform 160ms ease';
        img.classList.remove('grab', 'grabbing');
      });
    }

    // Helper clamp
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    // Pointer events for panning
    const swiperEl = document.querySelector('.mySwiper');

    // pointerdown -> start panning only when scale>1 and pointer inside .zoom-container
    swiperEl.addEventListener('pointerdown', (e) => {
      const container = e.target.closest('.zoom-container');
      if (!container || !activeImg || container !== activeContainer) return;
      if (currentScale <= 1) return; // don't capture when not zoomed

      isPanning = true;
      startX = e.clientX;
      startY = e.clientY;
      lastTx = tx;
      lastTy = ty;

      // recalc bounds for safe measure
      calculateBounds();

      // prevent swiper from moving while panning
      swiper.allowTouchMove = false;

      // visual cursor change
      activeImg.classList.add('grabbing');

      // capture pointer so we continue to receive updates
      try { container.setPointerCapture(e.pointerId); } catch (_) {}
    });

    // pointermove -> update translation
    swiperEl.addEventListener('pointermove', (e) => {
      if (!isPanning) return;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      tx = clamp(lastTx + dx, -maxX, maxX);
      ty = clamp(lastTy + dy, -maxY, maxY);
      applyTransform(false);
    });

    // pointerup / pointercancel -> stop panning
    const endPan = (e) => {
      if (!isPanning) return;
      isPanning = false;
      lastTx = tx;
      lastTy = ty;
      swiper.allowTouchMove = true;
      if (activeImg) activeImg.classList.remove('grabbing');
      // release capture
      const container = e.target.closest('.zoom-container') || activeContainer;
      try { container && container.releasePointerCapture && container.releasePointerCapture(e.pointerId); } catch (_) {}
    };
    swiperEl.addEventListener('pointerup', endPan);
    swiperEl.addEventListener('pointercancel', endPan);
    swiperEl.addEventListener('pointerleave', endPan);

    // Recalculate bounds if window resizes
    window.addEventListener('resize', () => {
      calculateBounds();
    });

    // When clicking/tapping the image while not panning, we should not stop swiper navigation:
    // (we intentionally don't block clicks when scale == 1)

    // Update active elements when slide changes
    swiper.on('slideChangeTransitionEnd', updateActiveElements);

    // Update button states
    function updateButtons() {
      zoomInBtn.disabled = (levelIndex >= zoomLevels.length - 1);
      zoomOutBtn.disabled = (levelIndex <= 0);
      resetBtn.disabled = (levelIndex === 0 && tx === 0 && ty === 0);
    }

    // Observe transforms and update buttons accordingly
    const observer = new MutationObserver(() => updateButtons());
    observer.observe(document.body, { attributes: true, subtree: true });

    // initial
    updateActiveElements();
    updateButtons();
  </script>
</body>
</html>
